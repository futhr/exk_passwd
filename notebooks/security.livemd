# ExkPasswd Security Analysis

```elixir
Mix.install([
  {:exk_passwd, "~> 0.1.0"},
  {:kino, "~> 0.12"}
])
```

## Introduction

This notebook explores the security aspects of ExkPasswd-generated passwords:

* **Entropy** - How much randomness/unpredictability
* **Strength ratings** - Weak, moderate, strong, very strong
* **Crack time estimates** - How long to brute force
* **Comparison** - Different configurations and their security

## What is Entropy?

**Entropy** measures the unpredictability of a password in bits. Higher is better.

* Each bit doubles the number of possibilities
* 40 bits = 1 trillion possibilities
* 60 bits = 1 quintillion possibilities
* 128 bits = effectively uncrackable

<!-- livebook:{"break_markdown":true} -->

### Calculating Entropy

ExkPasswd provides built-in entropy calculation:

```elixir
password = ExkPasswd.generate(:default)
entropy = ExkPasswd.Entropy.calculate(password)

IO.puts("Password: #{password}")
IO.puts("Entropy: #{Float.round(entropy, 2)} bits")
IO.puts("Possible combinations: 2^#{Float.round(entropy, 2)}")
```

## Strength Analysis

Get a comprehensive strength analysis:

```elixir
password = ExkPasswd.generate(:security)
strength = ExkPasswd.Strength.analyze(password)

IO.puts("Password: #{password}")
IO.puts("Rating: #{strength.rating}")
IO.puts("Entropy: #{Float.round(strength.entropy, 2)} bits")
IO.puts("Length: #{strength.length} characters")
IO.puts("Crack time: #{strength.crack_time_display}")
IO.puts("Has lowercase: #{strength.has_lowercase}")
IO.puts("Has uppercase: #{strength.has_uppercase}")
IO.puts("Has digits: #{strength.has_digits}")
IO.puts("Has symbols: #{strength.has_symbols}")
```

## Comparing Presets

Let's compare the security of different presets:

```elixir
presets = [:xkcd, :web32, :wifi, :security, :appleid, :default]

results =
  for preset <- presets do
    password = ExkPasswd.generate(preset)
    strength = ExkPasswd.Strength.analyze(password)

    %{
      preset: preset,
      password: password,
      length: strength.length,
      entropy: Float.round(strength.entropy, 1),
      rating: strength.rating,
      crack_time: strength.crack_time_display
    }
  end

# Display as table
IO.puts("\n| Preset | Length | Entropy | Rating | Crack Time |")
IO.puts("|--------|--------|---------|--------|------------|")

for r <- results do
  IO.puts(
    "| #{r.preset} | #{r.length} | #{r.entropy} bits | #{r.rating} | #{r.crack_time} |"
  )
end

:ok
```

## Word Count Impact

How does the number of words affect security?

```elixir
alias ExkPasswd.Config

word_counts = [2, 3, 4, 5, 6]

IO.puts("\n=== Impact of Word Count on Security ===\n")

for count <- word_counts do
  config = Config.new(num_words: count, case_transform: :lower, separator_character: "-")
  password = ExkPasswd.generate(config)
  strength = ExkPasswd.Strength.analyze(password)

  IO.puts("#{count} words: #{password}")
  IO.puts("  Entropy: #{Float.round(strength.entropy, 2)} bits")
  IO.puts("  Rating: #{strength.rating}")
  IO.puts("  Crack time: #{strength.crack_time_display}\n")
end

:ok
```

## Word Length Impact

Does using longer words make passwords more secure?

```elixir
length_configs = [
  {3, 4, "very short"},
  {4, 6, "short"},
  {6, 8, "medium"},
  {8, 10, "long"},
  {10, 12, "very long"}
]

IO.puts("\n=== Impact of Word Length on Security ===\n")

for {min, max, label} <- length_configs do
  config =
    Config.new(
      num_words: 3,
      word_length_min: min,
      word_length_max: max,
      separator_character: "-"
    )

  password = ExkPasswd.generate(config)
  strength = ExkPasswd.Strength.analyze(password)

  IO.puts("#{label} words (#{min}-#{max} chars): #{password}")
  IO.puts("  Entropy: #{Float.round(strength.entropy, 2)} bits")
  IO.puts("  Rating: #{strength.rating}\n")
end

:ok
```

## Case Transform Impact

How do case transformations affect security?

```elixir
transforms = [
  :lower,
  :upper,
  :capitalize,
  :alternate,
  :random,
  :invert
]

IO.puts("\n=== Impact of Case Transform on Security ===\n")

for transform <- transforms do
  config = Config.new(num_words: 3, case_transform: transform, separator_character: "-")
  password = ExkPasswd.generate(config)
  strength = ExkPasswd.Strength.analyze(password)

  IO.puts("#{transform}: #{password}")
  IO.puts("  Entropy: #{Float.round(strength.entropy, 2)} bits")
  IO.puts("  Rating: #{strength.rating}\n")
end

:ok
```

## Padding Impact

How much does adding numbers and symbols help?

```elixir
padding_configs = [
  {0, 0, 0, 0, "No padding"},
  {2, 0, 0, 0, "2 digits before"},
  {2, 2, 0, 0, "2 digits before & after"},
  {3, 3, 0, 0, "3 digits before & after"},
  {2, 2, 1, 1, "Digits + symbols"}
]

IO.puts("\n=== Impact of Padding on Security ===\n")

for {db, da, sb, sa, label} <- padding_configs do
  config =
    Config.new(
      num_words: 3,
      padding_type: :fixed,
      padding_digits_before: db,
      padding_digits_after: da,
      padding_symbols_before: sb,
      padding_symbols_after: sa,
      symbol_alphabet: "!@#$%^&*"
    )

  password = ExkPasswd.generate(config)
  strength = ExkPasswd.Strength.analyze(password)

  IO.puts("#{label}: #{password}")
  IO.puts("  Entropy: #{Float.round(strength.entropy, 2)} bits")
  IO.puts("  Rating: #{strength.rating}\n")
end

:ok
```

## Cryptographic Randomness

ExkPasswd uses `:crypto.strong_rand_bytes/1` for all random operations. This is:

* **Cryptographically secure** - Unpredictable even with knowledge of previous outputs
* **High-quality** - Passes statistical randomness tests
* **OS-provided** - Uses the operating system's entropy pool

<!-- livebook:{"break_markdown":true} -->

Let's verify randomness by generating many passwords and checking for duplicates:

```elixir
# Generate 10,000 passwords and check uniqueness
count = 10_000
passwords = ExkPasswd.Batch.generate_batch(count, :default)
unique_count = Enum.uniq(passwords) |> length()
duplicate_count = count - unique_count

IO.puts("Generated: #{count} passwords")
IO.puts("Unique: #{unique_count}")
IO.puts("Duplicates: #{duplicate_count}")
IO.puts("Uniqueness: #{Float.round(unique_count / count * 100, 2)}%")

if duplicate_count == 0 do
  IO.puts("\n✓ Perfect! No collisions detected.")
else
  IO.puts("\n⚠ Some duplicates found (expected with high volumes)")
end
```

## Security Recommendations

Based on this analysis:

<!-- livebook:{"break_markdown":true} -->

### Minimum Security

For basic security (personal accounts, low-risk):

```elixir
basic_config = Config.new(num_words: 3, padding_digits_after: 2)
basic_pwd = ExkPasswd.generate(basic_config)
basic_strength = ExkPasswd.Strength.analyze(basic_pwd)

IO.puts("Basic security config:")
IO.puts("Password: #{basic_pwd}")
IO.puts("Entropy: #{Float.round(basic_strength.entropy, 2)} bits (aim for 50+)")
```

### Strong Security

For important accounts (email, banking, work):

```elixir
strong_config =
  Config.new(
    num_words: 4,
    case_transform: :capitalize,
    padding_digits_before: 2,
    padding_digits_after: 2
  )

strong_pwd = ExkPasswd.generate(strong_config)
strong_strength = ExkPasswd.Strength.analyze(strong_pwd)

IO.puts("Strong security config:")
IO.puts("Password: #{strong_pwd}")
IO.puts("Entropy: #{Float.round(strong_strength.entropy, 2)} bits (aim for 70+)")
```

### Maximum Security

For critical systems (servers, encryption keys, admin accounts):

```elixir
max_pwd = ExkPasswd.generate(:security)
max_strength = ExkPasswd.Strength.analyze(max_pwd)

IO.puts("Maximum security config:")
IO.puts("Password: #{max_pwd}")
IO.puts("Entropy: #{Float.round(max_strength.entropy, 2)} bits (aim for 100+)")
```

## Interactive Security Explorer

Try different configurations and see their security impact:

```elixir
# Modify these values and re-run to experiment
my_config =
  Config.new(
    num_words: 4,
    word_length_min: 5,
    word_length_max: 8,
    case_transform: :capitalize,
    separator_character: "-",
    padding_digits_before: 2,
    padding_digits_after: 2,
    padding_symbols_after: 1,
    symbol_alphabet: "!@#$"
  )

password = ExkPasswd.generate(my_config)
strength = ExkPasswd.Strength.analyze(password)

IO.puts("Your password: #{password}")
IO.puts("\n=== Security Analysis ===")
IO.puts("Length: #{strength.length} characters")
IO.puts("Entropy: #{Float.round(strength.entropy, 2)} bits")
IO.puts("Rating: #{strength.rating}")
IO.puts("Estimated crack time: #{strength.crack_time_display}")
IO.puts("\n=== Character Types ===")
IO.puts("Lowercase: #{if strength.has_lowercase, do: "✓", else: "✗"}")
IO.puts("Uppercase: #{if strength.has_uppercase, do: "✓", else: "✗"}")
IO.puts("Digits: #{if strength.has_digits, do: "✓", else: "✗"}")
IO.puts("Symbols: #{if strength.has_symbols, do: "✓", else: "✗"}")
```

## Next Steps

* [Benchmarks](benchmarks.livemd) - Performance analysis
* [Advanced Usage](advanced.livemd) - Configuration details
* [Quick Start](quickstart.livemd) - Back to basics

## Further Reading

* [NIST Digital Identity Guidelines](https://pages.nist.gov/800-63-3/)
* [OWASP Password Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html)
* [XKCD #936](https://xkcd.com/936/) - The original inspiration
